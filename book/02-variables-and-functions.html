

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 (experimental) for Mac OS X https://github.com/w3c/tidy-html5/tree/c63cc39"/>

  <title></title>
</head>

<body>
  <section xmlns="http://www.w3.org/1999/xhtml" id="variables-and-functions" data-type="chapter">
    <h1>Variables and Functions</h1>

    <p>Variables and functions are fundamental ideas that show up
    in virtually all programming languages. OCaml has a different
    take on these concepts than most languages you're likely to
    have encountered, so this chapter will cover OCaml's approach
    to variables and functions in some detail, starting with the
    basics of how to define a variable, and ending with the
    intricacies of functions with labeled and optional
    arguments.</p>

    <p>Don't be discouraged if you find yourself overwhelmed by some
    of the details, especially toward the end of the chapter.  The
    concepts here are important, but if they don't connect for you on
    your first read, you should return to this chapter after you've
    gotten a better sense of the rest of the language.</p>

    <section id="variables" data-type="sect1">
      <h1>Variables</h1>

      <p>At its simplest, a variable is an identifier whose meaning
      is bound to a particular value. In OCaml these bindings are
      often introduced using the <code>let</code> keyword. We can
      type a so-called <em>top-level</em> <code>let</code> binding
      with the following syntax. Note that variable names must
      start with a lowercase letter or an
      underscore. <idx>bindings/top-level</idx><idx>top-level
      bindings</idx><idx>let syntax/top-level bindings</idx></p>
      <link rel="import" href="code/variables-and-functions/let.syntax"/>

      <p>As we'll see when we get to the module system
      in <a href="04-files-modules-and-programs.html#files-modules-and-programs"
      data-type="xref">Files Modules And Programs</a>, this same
      syntax is used for <code>let</code> bindings at the top level of
      a module.</p>

      <p>Every variable binding has a <em>scope</em>, which is the
      portion of the code that can refer to that binding. When
      using <span class="command"><em>utop</em></span>, the scope
      of a top-level <code>let</code> binding is everything that
      follows it in the session. When it shows up in a module, the
      scope is the remainder of that module.<idx>variables/scope
      of</idx><idx>bindings/scope of</idx><idx>scope</idx></p>

      <p>Here's a simple example.</p>
      <link rel="import" href="code/variables-and-functions/main.topscript" part="0.5"/>

      <p><code>let</code> can also be used to create a variable
      binding whose scope is limited to a particular expression,
      using the following syntax.</p>
      <link rel="import" href="code/variables-and-functions/let_in.syntax"/>

      <p>This first evaluates <em><code>expr1</code></em> and then
      evaluates <em><code>expr2</code></em>
      with <em><code>variable</code></em> bound to whatever value was
      produced by the evaluation of <em><code>expr1</code></em>.
      Here's how it looks in practice.</p>
      <link rel="import" href="code/variables-and-functions/main.topscript" part="1"/>

      <p>Note that the scope of <code>language_list</code> is just
      the expression <code>String.concat ~sep:"-"
      language_list</code> and is not available at the toplevel, as
      we can see if we try to access it now.</p>
      <link rel="import" href="code/variables-and-functions/main.topscript" part="2"/>

      <p>A <code>let</code> binding in an inner scope can
      <em>shadow</em>, or hide, the definition from an outer scope.
      So, for example, we could have written the
      <code>dashed_languages</code> example as
      follows. <idx>variables/shadowing
      of</idx><idx>shadowing</idx></p>
      <link rel="import" href="code/variables-and-functions/main.topscript" part="3"/>

      <p>This time, in the inner scope we called the list of
      strings <code>languages</code> instead of
      <code>language_list</code>, thus hiding the original
      definition of <code>languages</code>. But once the definition
      of <code>dashed_languages</code> is complete, the inner scope
      has closed and the original definition of languages
      is still available.</p>
      <link rel="import" href="code/variables-and-functions/main.topscript" part="4"/>

      <p>One common idiom is to use a series of nested
      <code>let</code>/<code>in</code> expressions to build up the
      components of a larger computation. Thus, we might
      write. <idx>let syntax/nested bindings</idx><idx>nested let
      binding</idx></p>
      <link rel="import" href="code/variables-and-functions/main.topscript" part="5"/>

      <p>It's important not to confuse a sequence of
      <code>let</code> bindings with the modification of a mutable
      variable. For example, consider how <code>area_of_ring</code>
      would work if we had instead written this purposefully
      confusing bit of code:</p>
      <link rel="import" href="code/variables-and-functions/main.topscript" part="6"/>

      <p>Here, we redefined <code>pi</code> to be zero after the
      definition of <code>area_of_circle</code>. You might think that
      this would mean that the result of the computation would now be
      zero, but in fact, the behavior of the function is
      unchanged. That's because the original definition
      of <code>pi</code> wasn't changed; it was just shadowed, which
      means that any subsequent reference to <code>pi</code> would see
      the new definition of <code>pi</code> as <code>0</code>, but
      earlier references would still see the old one. But there is no
      later use of <code>pi</code>, so the binding of <code>pi</code>
      to <code>0.</code> made no difference at all. This explains the
      warning produced by the toplevel telling us that there is an
      unused variable.</p>

      <p>In OCaml, <code>let</code> bindings are immutable. There
      are many kinds of mutable values in OCaml, which we'll
      discuss in <a href="08-imperative-programming.html#imperative-programming-1" data-type="xref">Imperative Programming</a>, but there are no
      mutable variables.</p>

      <div data-type="note">
        <h1>Why Don't Variables Vary?</h1>

        <p>One source of confusion for people new to OCaml is the
        fact that variables are immutable. This seems pretty
        surprising even on linguistic terms. Isn't the whole point
        of a variable that it can vary?<idx>variables/immutability
        of</idx></p>

        <p>The answer to this is that variables in OCaml (and
        generally in functional languages) are really more like
        variables in an equation than a variable in an imperative
        language. If you think about the mathematical identity
        <code>x(y + z) = xy + xz</code>, there's no notion of
        mutating the variables <code>x</code>, <code>y</code>, and
        <code>z</code>. They vary in the sense that you can
        instantiate this equation with different numbers for those
        variables, and it still holds.</p>

        <p>The same is true in a functional language. A function
        can be applied to different inputs, and thus its variables
        will take on different values, even without mutation.</p>
      </div>

      <section id="pattern-matching-and-let" data-type="sect2">
        <h2>Pattern Matching and let</h2>

        <p>Another useful feature of <code>let</code> bindings is that
        they support the use of <em>patterns</em> on the left-hand
        side. Consider the following code, which
        uses <code>List.unzip</code>, a function for converting a list
        of pairs into a pair of lists.<idx>pattern matching/and
        let</idx><idx>let syntax/pattern
        matching</idx><idx>variables/pattern matching in</idx></p>
        <link rel="import"
        href="code/variables-and-functions/main.topscript" part="7"/>

        <p>Here, <code>(ints,strings)</code> is a pattern, and
        the <code>let</code> binding assigns values to both of the
        identifiers that show up in that pattern. A pattern is
        essentially a description of the shape of a data structure,
        where some components are names to be bound to values. As we
        saw
        in <a href="01-guided-tour.html#tuples-lists-options-and-pattern-matching"
        data-type="xref">Tuples Lists Options And Pattern
        Matching</a>, OCaml has patterns for a variety of different
        data types.</p>

        <p>Using a pattern in a <code>let</code> binding makes the
        most sense for a pattern that is <em>irrefutable</em>,
        <em>i.e.</em>, where any value of the type in question is
        guaranteed to match the pattern. Tuple and record patterns
        are irrefutable, but list patterns are not. Consider the
        following code that implements a function for upper casing
        the first element of a comma-separated
        list.<idx>irrefutable patterns</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="8"/>

        <p>This case can't really come up in practice,
        because <code>String.split</code> always returns a list with
        at least one element, even when given the empty string.
        <link rel="import"
        href="code/variables-and-functions/main.topscript"
        part="8.1"/>

	But the compiler doesn't know this, and so it emits the
        warning. It's generally better to use a <code>match</code>
        statement to handle such cases explicitly.</p>
        <link rel="import"
        href="code/variables-and-functions/main.topscript" part="9"/>

        <p>Note that this is our first use of <code>assert</code>,
        which is useful for marking cases that should be
        impossible. We'll discuss <code>assert</code> in more
        detail in <a href="07-error-handling.html#error-handling" data-type="xref">Error Handling</a>.</p>
      </section>
    </section>

    <section id="functions" data-type="sect1">
      <h1>Functions</h1>

      <p>Given that OCaml is a functional language, it's no
      surprise that functions are important and pervasive. Indeed,
      functions have come up in almost every example we've done so
      far. This section will go into more depth, explaining the
      details of how OCaml's functions work. As you'll see,
      functions in OCaml differ in a variety of ways from what
      you'll find in most mainstream languages.</p>

      <section id="anonymous-functions" data-type="sect2">
        <h2>Anonymous Functions</h2>

        <p>We'll start by looking at the most basic style of
        function declaration in OCaml: the <em>anonymous
        function</em>. An anonymous function is a function that is
        declared without being named. These can be declared using
        the <code>fun</code> keyword, as shown here. <idx>fun
        keyword/anonymous functions</idx><idx>anonymous
        functions</idx><idx>functions/anonymous functions</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="10"/>

        <p>Anonymous functions operate in much the same way as
        named functions. For example, we can apply an anonymous
        function to an argument. </p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="11"/> 

        <p>Or pass it to another function. Passing functions to
        iteration functions like <code>List.map</code> is probably
        the most common use case for anonymous functions.</p>
        <link rel="import"
        href="code/variables-and-functions/main.topscript" part="12"/> 

        <p>You can even stuff a function into a data structure, like a
        list.</p>

        <link rel="import" 
	      href="code/variables-and-functions/main.topscript"
	      part="13" />

        <p>
	  It's worth stopping for a moment to puzzle this example
          out, since this kind of higher-order use of functions can be a
          bit obscure at first. Notice that <code>(fun g -&gt; g "Hello
            World")</code> is a function that takes a function as an
          argument, and then applies that function to the
          string <code>"Hello World"</code>. The invocation
          of <code>List.map</code> applies <code>(fun g -&gt; g "Hello
            World")</code> to the elements of <code>transforms</code>,
          which are themselves functions.  The returned list
          containing the results of these function applications.</p>

        <p>The key thing to understand is that functions are
        ordinary values in OCaml, and you can do everything with
        them that you'd do with an ordinary value, including
        passing them to and returning them from other functions and
        storing them in data structures. We even name functions in
        the same way that we name other values, by using a
        <code>let</code> binding.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="14"/>

        <p>Defining named functions is so common that there is some
        syntactic sugar for it. Thus, the following definition of
        <code>plusone</code> is equivalent to the previous
        definition.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="15"/>

        <p>This is the most common and convenient way to declare a
        function, but syntactic niceties aside, the two styles of
        function definition are equivalent.</p>

        <div data-type="note">
          <h1>let and fun</h1>

          <p>Functions and <code>let</code> bindings have a lot to
          do with each other. In some sense, you can think of the
          parameter of a function as a variable being bound to the
          value passed by the caller. Indeed, the following two
          expressions are nearly equivalent. <idx>let
          syntax/functions and</idx></p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="16"/>

          <p>This connection is important, and will come up more
          when programming in a monadic style, as we'll see in
          <a href="18-concurrent-programming.html#concurrent-programming-with-async" data-type="xref">Concurrent Programming With
          Async</a>.</p>
        </div>
      </section>

      <section id="multi-argument-functions" data-type="sect2">
        <h2>Multiargument functions</h2>

        <p>OCaml of course also supports multiargument functions,
        such as:<idx>fun keyword/multi-argument
        functions</idx><idx>multi-argument
        functions</idx><idx>functions/multi-argument
        functions</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="17"/>

        <p>You may find the type signature of <code>abs_diff</code>
        with all of its arrows a little hard to parse. To
        understand what's going on, let's rewrite
        <code>abs_diff</code> in an equivalent form, using the
        <code>fun</code> keyword.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="18"/>

        <p>This rewrite makes it explicit that
        <code>abs_diff</code> is actually a function of one
        argument that returns another function of one argument,
        which itself returns the final result. Because the
        functions are nested, the inner expression <code>abs (x -
        y)</code> has access to both <code>x</code>, which was
        bound by the outer function application, and
        <code>y</code>, which was bound by the inner one.</p>

        <p>
	  This style of function is called a <em>curried</em>
          function. (Currying is named after Haskell Curry, a logician
          who had a significant impact on the design and theory of
          programming languages.) The key to interpreting the type
          signature of a curried function is the observation
          that <code>-&gt;</code> is right-associative. The type
          signature of <code>abs_diff</code> can therefore be
          parenthesized as follows.

	  <idx>curried functions</idx>
	  <idx>functions/curried functions</idx></p>

        <link rel="import" href="code/variables-and-functions/abs_diff.mli" />

        <p>The parentheses don't change the meaning of the
        signature, but they make it easier to see the currying.</p>

        <p>
	  Currying is more than just a theoretical curiosity. You can
          make use of currying to specialize a function by feeding in
          some of the arguments. Here's an example where we create a
          specialized version of <code>abs_diff</code> that measures
          the distance of a given number from <code>3</code>.</p>
	
        <link rel="import" 
	      href="code/variables-and-functions/main.topscript"
	      part="19" /> 

        <p>The practice of applying some of the arguments of a curried
        function to get a new function is called <em>partial
        application</em>.<idx>partial application</idx></p>

        <p>Note that the <code>fun</code> keyword supports its own
        syntax for currying, so the following definition
        of <code>abs_diff</code> is equivalent to the previous
        one.<idx>fun keyword/currying syntax</idx></p>
        <link rel="import"
        href="code/variables-and-functions/main.topscript" part="20"/>

        <p>You might worry that curried functions are terribly
        expensive, but this is not the case. In OCaml, there is no
        penalty for calling a curried function with all of its
        arguments. (Partial application, unsurprisingly, does have a
        small extra cost.)</p>

        <p>Currying is not the only way of writing a multiargument
        function in OCaml. It's also possible to use the different
        parts of a tuple as different arguments. So, we could
        write.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="21"/>

        <p>OCaml handles this calling convention efficiently as
        well. In particular it does not generally have to allocate
        a tuple just for the purpose of sending arguments to a
        tuple-style function. You can't, however, use partial
        application for this style of function.</p>

        <p>There are small trade-offs between these two approaches,
        but most of the time, one should stick to currying, since
        it's the default style in the OCaml world.</p>
      </section>

      <section id="recursive-functions" data-type="sect2">
        <h2>Recursive Functions</h2>

        <p>A function is <em>recursive</em> if it refers to itself
        in its definition. Recursion is important in any
        programming language, but is particularly important in
        functional languages, because it is the way that you build
        looping constructs. (As will be discussed in more detail in
        <a href="08-imperative-programming.html#imperative-programming-1" data-type="xref">Imperative Programming 1</a>, OCaml also
        supports imperative looping constructs like
        <code>for</code> and <code>while</code>, but these are only
        useful when using OCaml's imperative
        features.)<idx>recursive functions/definition
        of</idx><idx>functions/recursive functions</idx></p>

        <p>In order to define a recursive function, you need to
        mark the <code>let</code> binding as recursive with the
        <code>rec</code> keyword, as shown in this function for
        finding the first sequentially repeated element in a
        list.<idx>rec keyword</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="22"/>

        <p>
	  The pattern <code>[] | [_]</code> is itself a disjunction of
          multiple patterns, otherwise known as
          an <em>or-pattern</em>. An or-pattern matches if any of the
          sub-patterns match. In this case, <code>[]</code> matches
          the empty list, and <code>[_]</code> matches any single
          element list. The <code>_</code> is there so we don't have
          to put an explicit name on that single
          element.<idx>or-patterns</idx></p>

        <p>
	  We can also define multiple mutually recursive values by
          using <code>let rec</code> combined with
          the <code>and</code> keyword. Here's a (gratuitously
          inefficient) example.</p>

        <link rel="import" href="code/variables-and-functions/main.topscript" part="23" />

        <p>
	  OCaml distinguishes between nonrecursive definitions
          (using <code>let</code>) and recursive definitions
          (using <code>let rec</code>) largely for technical reasons:
          the type-inference algorithm needs to know when a set of
          function definitions are mutually recursive, and these have
          to be marked explicitly by the programmer.
	  
	  <idx>let syntax/nonrecursive vs. recursive functions</idx></p>

        <p>
	  But this decision has some good effects. For one thing,
          recursive (and especially mutually recursive) definitions
          are harder to reason about than nonrecursive ones. It's
          therefore useful that, in the absence of an
          explicit <code>rec</code>, you can assume that
          a <code>let</code> binding is nonrecursive, and so can only
          build upon previous definitions.</p>

        <p>
	  In addition, having a nonrecursive form makes it easier to
          create a new definition that extends and supersedes an
          existing one by shadowing it.</p>
      </section>

      <section id="prefix-and-infix-operators" data-type="sect2">
        <h2>Prefix and Infix Operators</h2>

        <p>So far, we've seen examples of functions used in both
        prefix and infix style.<idx>operators/prefix and infix
        operators</idx><idx>infix operators</idx><idx>prefix
        operators</idx><idx id="FNCprf">functions/prefix and infix
        operators</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="24"/>

        <p>You might not have thought of the second example as an
        ordinary function, but it very much is. Infix operators
        like <code>+</code> really only differ syntactically from
        other functions. In fact, if we put parentheses around an
        infix operator, you can use it as an ordinary prefix
        function.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="25"/>

        <p>In the second expression, we've partially applied
        <code>(+)</code> to create a function that increments its
        single argument by <code>3</code>.</p>

        <p>A function is treated syntactically as an operator if
        the name of that function is chosen from one of a
        specialized set of identifiers. This set includes
        identifiers that are sequences of characters from the
        following set:</p>
        <link rel="import" href="code/variables-and-functions/operators.syntax"/>

        <p>or is one of a handful of predetermined strings,
        including <code>mod</code>, the modulus operator,
        and <code>lsl</code>, for "logical shift left," a bit-shifting
        operation.</p>

        <p>We can define (or redefine) the meaning of an operator.
        Here's an example of a simple vector-addition operator on
        <code>int</code> pairs.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="26"/>

        <p>Note that you have to be careful when dealing with
        operators containing <code>*</code>. Consider the following
        example.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="27"/>

        <p>What's going on is that <code>(***)</code> isn't
        interpreted as an operator at all; it's read as a comment!
        To get this to work properly, we need to put spaces around
        any operator that begins or ends with <code>*</code>.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="28"/>

        <p>The syntactic role of an operator is typically
        determined by its first character or two, though there are
        a few exceptions. <a href="02-variables-and-functions.html#table2_1" data-type="xref">Table2_1</a> breaks the different operators and
        other syntactic forms into groups from highest to lowest
        precedence, explaining how each behaves syntactically. We
        write <code>!</code>... to indicate the class of operators
        beginning with <code>!</code>.</p>

        <table id="table2_1">
          <caption>
            Precedence and associativity
          </caption>

          <thead>
            <tr>
              <th>Operator prefix</th>

              <th>Associativity</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><code>!</code>..., <code>?</code>...,
              <code>~</code>...</td>

              <td>Prefix</td>
            </tr>

            <tr>
              <td><code>.</code>, <code>.(</code>,
              <code>.[</code></td>

              <td>-</td>
            </tr>

            <tr>
              <td>function application, constructor,
              <code>assert</code>, <code>lazy</code></td>

              <td>Left associative</td>
            </tr>

            <tr>
              <td><code>-</code>, <code>-.</code></td>

              <td>Prefix</td>
            </tr>

            <tr>
              <td><code>**</code>..., <code>lsl</code>,
              <code>lsr</code>, <code>asr</code></td>

              <td>Right associative</td>
            </tr>

            <tr>
              <td><code>*</code>..., <code>/</code>...,
              <code>%</code>..., <code>mod</code>,
              <code>land</code>, <code>lor</code>,
              <code>lxor</code></td>

              <td>Left associative</td>
            </tr>

            <tr>
              <td><code>+</code>..., <code>-</code>...</td>

              <td>Left associative</td>
            </tr>

            <tr>
              <td><code>::</code></td>

              <td>Right associative</td>
            </tr>

            <tr>
              <td><code>@</code>..., <code>^</code>...</td>

              <td>Right associative</td>
            </tr>

            <tr>
              <td><code>=</code>..., <code>&lt;</code>...,
              <code>&gt;</code>..., <code>|</code>...,
              <code>&amp;</code>..., <code>$</code>...</td>

              <td>Left associative</td>
            </tr>

            <tr>
              <td><code>&amp;</code>, <code>&amp;&amp;</code></td>

              <td>Right associative</td>
            </tr>

            <tr>
              <td><code>or</code>, <code>||</code></td>

              <td>Right associative</td>
            </tr>

            <tr>
              <td><code>,</code></td>

              <td>-</td>
            </tr>

            <tr>
              <td><code>&lt;-</code>, <code>:=</code></td>

              <td>Right associative</td>
            </tr>

            <tr>
              <td><code>if</code></td>

              <td>-</td>
            </tr>

            <tr>
              <td><code>;</code></td>

              <td>Right associative</td>
            </tr>
          </tbody>
        </table>

        <p>There's one important special case: <code>-</code> and
        <code>-.</code>, which are the integer and floating-point
        subtraction operators, and can act as both prefix operators
        (for negation) and infix operators (for subtraction). So,
        both <code>-x</code> and <code>x - y</code> are meaningful
        expressions. Another thing to remember about negation is
        that it has lower precedence than function application,
        which means that if you want to pass a negative value, you
        need to wrap it in parentheses, as you can see in this
        code.<idx>operators/negation
        operators</idx><idx>operators/subtraction
        operators</idx><idx>subtraction
        operators</idx><idx>negation operators</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="29"/>

        <p>Here, OCaml is interpreting the second expression as
        equivalent to.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="30"/>

        <p>which obviously doesn't make sense.</p>

        <p>Here's an example of a very useful operator from the
        standard library whose behavior depends critically on the
        precedence rules described previously.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="31"/>

        <p>It's not quite obvious at first what the purpose of this
        operator is: it just takes a value and a function and
        applies the function to the value. Despite that
        bland-sounding description, it has the useful role of a
        sequencing operator, similar in spirit to using the pipe
        character in the UNIX shell. Consider, for example, the
        following code for printing out the unique elements of your
        <code>PATH</code>. Note that <code>List.dedup</code> that
        follows removes duplicates from a list by sorting the list
        using the provided comparison function.<idx>lists/duplicate
        removal</idx><idx>duplicates,
        removing</idx><idx>List.dedup</idx><idx>operators/sequencing
        operators</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="32"/>

        <p>We can do this without <code>|&gt;</code> by naming the
        intermediate values, but the result is a bit more verbose.</p>
        <link rel="import"
        href="code/variables-and-functions/main.topscript" part="33"/>

        <p>An important part of what's happening here is partial
        application. For example, <code>List.iter</code> takes two
        arguments: a function to be called on each element of the
        list, and the list to iterate over. We can
        call <code>List.iter</code> with all its
        arguments.  <idx>partial application</idx></p>
        <link rel="import"
        href="code/variables-and-functions/main.topscript" part="34"/>

        <p>Or, we can pass it just the function argument, leaving
        us with a function for printing out a list of strings.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="35"/>

        <p>It is this later form that we're using in the preceding
        <code>|&gt;</code> pipeline.</p>

        <p>But <code>|&gt;</code> only works in the intended way
        because it is left-associative. Let's see what happens if
        we try using a right-associative operator, like
        (^&gt;).</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="36"/>

        <p>The type error is a little bewildering at first glance.
        What's going on is that, because <code>^&gt;</code> is
        right associative, the operator is trying to feed the value
        <code>List.dedup ~compare:String.compare</code> to the
        function <code>List.iter ~f:print_endline</code>. But
        <code>List.iter ~f:print_endline</code> expects a list of
        strings as its input, not a function.</p>

        <p>The type error aside, this example highlights the
        importance of choosing the operator you use with care,
        particularly with respect to associativity.<a data-type="indexterm" data-startref="FNCprf">&nbsp;</a></p>
      </section>

      <section id="declaring-functions-with-function" data-type="sect2">
        <h2>Declaring Functions with <code>function</code></h2>

        <p>Another way to define a function is using the
        <code>function</code> keyword. Instead of having syntactic
        support for declaring multiargument (curried) functions,
        <code>function</code> has built-in pattern matching. Here's
        an example.<idx>functions/defining</idx><idx>function
        keyword</idx><idx>functions/declaring with function
        keyword</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="37"/>

        <p>This is equivalent to combining an ordinary function
        definition with a <code>match</code>.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="38"/>

        <p>We can also combine the different styles of function
        declaration together, as in the following example, where we
        declare a two-argument (curried) function with a pattern
        match on the second argument.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="39"/>

        <p>Also, note the use of partial application to generate
        the function passed to <code>List.map</code>. In other
        words, <code>some_or_default 100</code> is a function that
        was created by feeding just the first argument to
        <code>some_or_default</code>.</p>
      </section>

      <section id="labeled-arguments" data-type="sect2">
        <h2>Labeled Arguments</h2>

        <p>Up until now, the functions we've defined have specified
        their arguments positionally, <em>i.e.</em>, by the order in
        which the arguments are passed to the function. OCaml also
        supports labeled arguments, which let you identify a function
        argument by name. Indeed, we've already encountered functions
        from <code>Base</code> like <code>List.map</code> that use labeled
        arguments. Labeled arguments are marked by a leading tilde,
        and a label (followed by a colon) is put in front of the
        variable to be labeled. Here's an example.<idx>labeled
        arguments</idx><idx>arguments/labeled
        arguments</idx><idx>functions/labeled arguments</idx></p>
        <link rel="import"
        href="code/variables-and-functions/main.topscript" part="40"/>

        <p>We can then provide a labeled argument using a similar
        convention. As you can see, the arguments can be provided
        in any order.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="41"/>

        <p>OCaml also supports <em>label punning</em>, meaning that
        you get to drop the text after the <code>:</code> if the
        name of the label and the name of the variable being used
        are the same. We were actually already using label punning
        when defining <code>ratio</code>. The following shows how
        punning can be used when invoking a
        function.<idx>punning</idx><idx>label punning</idx></p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="42"/>

        <p>Labeled arguments are useful in a few different
        cases:</p>

        <ul>
          <li>
            <p>When defining a function with lots of arguments.
            Beyond a certain number, arguments are easier to
            remember by name than by position.<idx>functions/with
            multiple arguments</idx><idx>multi-argument
            functions</idx></p>
          </li>

          <li>
            <p>When the meaning of a particular argument is unclear
            from the type alone. Consider a function for creating a
            hash table whose first argument is the initial size of
            the array backing the hash table, and the second is a
            Boolean flag, which indicates whether that array will
            ever shrink when elements are removed.</p>
            <link rel="import" href="code/variables-and-functions/htable_sig1.ml"/>

            <p>The signature makes it hard to divine the meaning of
            those two arguments. but with labeled arguments, we can
            make the intent immediately clear.</p>
            <link rel="import" href="code/variables-and-functions/htable_sig2.ml"/>

            <p>Choosing label names well is especially important
            for Boolean values, since it's often easy to get
            confused about whether a value being true is meant to
            enable or disable a given feature.</p>
          </li>

          <li>
            <p>When defining functions that have multiple arguments
            that might get confused with each other. This is most
            at issue when the arguments are of the same type. For
            example, consider this signature for a function that
            extracts a substring.</p>
            <link rel="import" href="code/variables-and-functions/substring_sig1.ml"/>

            <p>Here, the two <code>ints</code> are the starting
            position and length of the substring to extract,
            respectively, but you wouldn't know that from the type
            signature.  We can make the signature more informative by
            adding labels.</p>

	    <link rel="import"
	    href="code/variables-and-functions/substring_sig2.ml"/>

            <p>This improves the readability of both the signature
            and of client code that makes use of
            <code>substring</code> and makes it harder to
            accidentally swap the position and the length.</p>
          </li>

          <li>
            <p>When you want flexibility on the order in which
            arguments are passed. Consider a function like
            <code>List.iter</code>, which takes two arguments. a
            function and a list of elements to call that function
            on. A common pattern is to partially apply
            <code>List.iter</code> by giving it just the function,
            as in the following example from earlier in the
            chapter.</p>
            <link rel="import" href="code/variables-and-functions/main.topscript" part="43"/>

            <p>This requires that we put the function argument
            first. In other cases, you want to put the function
            argument second. One common reason is readability. In
            particular, a multiline function passed as an argument
            to another function is easiest to read when it is the
            final argument to that function.</p>
          </li>
        </ul>

        <section id="higher-order-functions-and-labels" data-type="sect3">
          <h3>Higher-order functions and labels</h3>

          <p>One surprising gotcha with labeled arguments is that
          while order doesn't matter when calling a function with
          labeled arguments, it does matter in a higher-order
          context, <em>e.g.</em>, when passing a function with
          labeled arguments to another function. Here's an
          example.<idx>higher-order functions, and
          labels</idx><idx>functions/higher-order and
          labels</idx></p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="44"/>

          <p>Here, the definition of <code>apply_to_tuple</code>
          sets up the expectation that its first argument is a
          function with two labeled arguments, <code>first</code>
          and <code>second</code>, listed in that order. We could
          have defined <code>apply_to_tuple</code> differently to
          change the order in which the labeled arguments were
          listed.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="45"/>

          <p>It turns out this order matters. In particular, if we
          define a function that has a different order</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="46"/>

          <p>we'll find that it can't be passed in to
          <code>apply_to_tuple_2</code>.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="47"/>

          <p>But, it works smoothly with the original
          <code>apply_to_tuple</code>.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="48"/>

          <p>As a result, when passing labeled functions as
          arguments, you need to take care to be consistent in your
          ordering of labeled arguments.</p>
        </section>
      </section>

      <section id="optional-arguments" data-type="sect2">
        <h2>Optional Arguments</h2>

        <p>An optional argument is like a labeled argument that the
        caller can choose whether or not to provide. Optional
        arguments are passed in using the same syntax as labeled
        arguments, and, like labeled arguments, can be provided in
        any order.<idx id="ARGopt">arguments/optional
        arguments</idx><idx id="FNCopt">functions/optional
        arguments</idx></p>

        <p>Here's an example of a string concatenation function
        with an optional separator. This function uses the
        <code>^</code> operator for pairwise string
        concatenation.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="49"/>

        <p>Here, <code>?</code> is used in the definition of the
        function to mark <code>sep</code> as optional. And while
        the caller can pass a value of type <code>string</code> for
        <code>sep</code>, internally to the function,
        <code>sep</code> is seen as a <code>string option</code>,
        with <code>None</code> appearing when <code>sep</code> is
        not provided by the caller.</p>

        <p>The preceding example needed a bit of boilerplate to
        choose a default separator when none was provided. This is
        a common enough pattern that there's an explicit syntax for
        providing a default value, which allows us to write
        <code>concat</code> more concisely.</p>
        <link rel="import" href="code/variables-and-functions/main.topscript" part="50"/>

        <p>Optional arguments are very useful, but they're also
        easy to abuse. The key advantage of optional arguments is
        that they let you write functions with multiple arguments
        that users can ignore most of the time, only worrying about
        them when they specifically want to invoke those options.
        They also allow you to extend an API with new functionality
        without changing existing code.</p>

        <p>The downside is that the caller may be unaware that
        there is a choice to be made, and so may unknowingly (and
        wrongly) pick the default behavior. Optional arguments
        really only make sense when the extra concision of omitting
        the argument outweighs the corresponding loss of
        explicitness.</p>

        <p>This means that rarely used functions should not have
        optional arguments. A good rule of thumb is to avoid
        optional arguments for functions internal to a module,
        <em>i.e.</em>, functions that are not included in the
        module's interface, or <code>mli</code> file. We'll learn
        more about <code>mli</code>s in <a href="04-files-modules-and-programs.html#files-modules-and-programs" data-type="xref">Files Modules And Programs</a>.</p>

        <section id="explicit-passing-of-an-optional-argument" data-type="sect3">
          <h3>Explicit passing of an optional argument</h3>

          <p>Under the covers, a function with an optional argument
          receives <code>None</code> when the caller doesn't
          provide the argument, and <code>Some</code> when it does.
          But the <code>Some</code> and <code>None</code> are
          normally not explicitly passed in by the caller.</p>

          <p>But sometimes, passing in <code>Some</code> or
          <code>None</code> explicitly is exactly what you want.
          OCaml lets you do this by using <code>?</code> instead of
          <code>~</code> to mark the argument. Thus, the following
          two lines are equivalent ways of specifying the
          <code>sep</code> argument to
          <code>concat</code>.<idx>optional arguments/explicit
          passing of</idx></p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="51"/>

          <p>And the following two lines are equivalent ways of
          calling <code>concat</code> without specifying
          <code>sep</code>.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="52"/>

          <p>One use case for this is when you want to define a
          wrapper function that mimics the optional arguments of
          the function it's wrapping. For example, imagine we
          wanted to create a function called
          <code>uppercase_concat</code>, which is the same as
          <code>concat</code> except that it converts the first
          string that it's passed to uppercase. We could write the
          function as follows.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="53"/>

          <p>In the way we've written it, we've been forced to
          separately make the decision as to what the default
          separator is. Thus, if we later change
          <code>concat</code>'s default behavior, we'll need to
          remember to change <code>uppercase_concat</code> to match
          it.</p>

          <p>Instead, we can have <code>uppercase_concat</code>
          simply pass through the optional argument to
          <code>concat</code> using the <code>?</code> syntax.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="54"/>

          <p>Now, if someone calls <code>uppercase_concat</code>
          without an argument, an explicit <code>None</code> will
          be passed to <code>concat</code>, leaving
          <code>concat</code> to decide what the default behavior
          should be.</p>
        </section>

        <section id="inference-of-labeled-and-optional-arguments" data-type="sect3">
          <h3>Inference of labeled and optional arguments</h3>

          <p>One subtle aspect of labeled and optional arguments is
          how they are inferred by the type system. Consider the
          following example for computing numerical derivatives of
          a function of two real variables. The function takes an
          argument <code>delta</code>, which determines the scale
          at which to compute the derivative; values <code>x</code>
          and <code>y</code>, which determine at which point to
          compute the derivative; and the function <code>f</code>,
          whose derivative is being computed. The function
          <code>f</code> itself takes two labeled arguments,
          <code>x</code> and <code>y</code>. Note that you can use
          an apostrophe as part of a variable name, so
          <code>x'</code> and <code>y'</code> are just ordinary
          variables.<idx>functions/argument
          inference</idx><idx>labeled
          arguments</idx><idx>arguments/inference
          of</idx><idx>optional arguments/inference of</idx></p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="55"/>

          <p>In principle, it's not obvious how the order of the
          arguments to <code>f</code> should be chosen. Since
          labeled arguments can be passed in arbitrary order, it
          seems like it could as well be <code>y:float -&gt;
          x:float -&gt; float</code> as it is <code>x:float -&gt;
          y:float -&gt; float</code>.</p>

          <p>Even worse, it would be perfectly consistent for
          <code>f</code> to take an optional argument instead of a
          labeled one, which could lead to this type signature for
          <code>numeric_deriv</code>.</p>
          <link rel="import" href="code/variables-and-functions/numerical_deriv_alt_sig.mli"/>

          <p>Since there are multiple plausible types to choose
          from, OCaml needs some heuristic for choosing between
          them. The heuristic the compiler uses is to prefer labels
          to options and to choose the order of arguments that
          shows up in the source code.</p>

          <p>Note that these heuristics might at different points
          in the source suggest different types. Here's a version
          of <code>numeric_deriv</code> where different invocations
          of <code>f</code> list the arguments in different
          orders.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="56"/>

          <p>As suggested by the error message, we can get OCaml to
          accept the fact that <code>f</code> is used with
          different argument orders if we provide explicit type
          information. Thus, the following code compiles without
          error, due to the type annotation on
          <code>f</code>.<idx>type annotations</idx></p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="57"/>
        </section>

        <section id="optional-arguments-and-partial-application" data-type="sect3">
          <h3>Optional arguments and partial application</h3>

          <p>Optional arguments can be tricky to think about in the
          presence of partial application. We can of course
          partially apply the optional argument itself.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="58"/>

          <p>But what happens if we partially apply just the first
          argument?</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="59"/>

          <p>The optional argument <code>?sep</code> has now
          disappeared, or been <em>erased</em>. Indeed, if we try
          to pass in that optional argument now, it will be
          rejected.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="60"/>

          <p>So when does OCaml decide to erase an optional
          argument?</p>

          <p>The rule is: an optional argument is erased as soon as
          the first positional (i.e., neither labeled nor optional)
          argument defined <em>after</em> the optional argument is
          passed in. That explains the behavior of
          <code>prepend_pound</code>. But if we had instead defined
          <code>concat</code> with the optional argument in the
          second position.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="61"/>

          <p>then application of the first argument would not cause
          the optional argument to be erased.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="62"/>

          <p>However, if all arguments to a function are presented
          at once, then erasure of optional arguments isn't applied
          until all of the arguments are passed in. This preserves
          our ability to pass in optional arguments anywhere on the
          argument list. Thus, we can write.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="63"/>

          <p>An optional argument that doesn't have any following
          positional arguments can't be erased at all, which leads
          to a compiler warning.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="64"/>

          <p>And indeed, when we provide the two positional
          arguments, the <code>sep</code> argument is not erased,
          instead returning a function that expects the
          <code>sep</code> argument to be provided.</p>
          <link rel="import" href="code/variables-and-functions/main.topscript" part="65"/>

          <p>As you can see, OCaml's support for labeled and
          optional arguments is not without its complexities. But
          don't let these complexities obscure the usefulness of
          these features. Labels and optional arguments are very
          effective tools for making your APIs both more convenient
          and safer, and it's worth the effort of learning how to
          use them effectively.<a data-type="indexterm" data-startref="ARGopt">&nbsp;</a><a data-type="indexterm" data-startref="FNCopt">&nbsp;</a></p>
        </section>
      </section>
    </section>
  </section>
</body>
</html>
